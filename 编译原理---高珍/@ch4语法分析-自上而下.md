# 本章不考

两种语法分析方法：

![image-20211009103132665](ch4语法分析-自上而下.assets/image-20211009103132665.png)

最右归约是最左推导的逆过程

下图最下面两个生成树从上到下是最左推导，右上角的粉色字是最右归约（利用栈完成）。

![image-20211009103714303](ch4语法分析-自上而下.assets/image-20211009103714303.png)

# 自上而下分析

定义：

从文法的开始符号出发，向下推导，推出句子 

对任何的输入串(单词符号)，试图用一切可 能的办法, 从文法的开始符号出发，自上而 下地为输入串建立一棵语法树，即为输入 串寻找一个最左推导。

试探法

![image-20211009104356872](ch4语法分析-自上而下.assets/image-20211009104356872.png)

# 左递归

## 定义&人工消去

也就是说下面的推导，A可以变成一个A后面跟若干个beta的形式

![image-20211009104306032](ch4语法分析-自上而下.assets/image-20211009104306032.png)

直接左递归

方法：递归没办法拿掉，因此考虑将左递归转换成右递归

最终目的：推导成一个P（也就是beta）后面跟若干个beta的形式。左递归写成了一个式子，右递归就是把拆成两个式子，也就是：前面的P写成beta+P‘；P’为若干个alpha或者空串；

![image-20211009105512979](ch4语法分析-自上而下.assets/image-20211009105512979.png)

改写通式：

![image-20211009110000493](ch4语法分析-自上而下.assets/image-20211009110000493.png)



改写例子：

![image-20211009105406848](ch4语法分析-自上而下.assets/image-20211009105406848.png)

第一个：T后面跟若干个+T
第二个：F跟若干个*F

![image-20211009105936093](ch4语法分析-自上而下.assets/image-20211009105936093.png)

## 算法消除递归

![image-20211009110603783](ch4语法分析-自上而下.assets/image-20211009110603783.png)



![image-20211108092229989](ch4语法分析-自上而下.assets/image-20211108092229989.png)

1前面没有直接

2前面有一个产生式，Q有没有以前面的产生式非终结符打头的，有，就带进来。观察有没有直接左递归，没有。

3前面有两个产生式，S有没有以前面的产生式非终结符打头的，有，就带进来。观察有没有直接左递归，有，故消去

观察哪个是产生式的起始符，

Question：为什么最后没有消除前两句

![image-20211108092505403](ch4语法分析-自上而下.assets/image-20211108092505403.png)

# 回溯

## 定义

试探，穷尽所有的可能性。

![image-20211014081544372](ch4语法分析-自上而下.assets/image-20211014081544372.png)

应该做到无回溯：对任非终结符A，用它匹配输入串时能够根据当 前输入，准确地指派一个候选式。

- 若匹配成功，则不虚假； 

- 若匹配不成功，则其它的候选式也不会成功。

## 解决方法

对每个非终结符的候选式，其任何推导的头符号（终结符）集合两两不相交。

![image-20211014083946264](ch4语法分析-自上而下.assets/image-20211014083946264.png)

例题：
步骤：先提取公因式再引入新符号代替括号里的部分

![image-20211014084017760](ch4语法分析-自上而下.assets/image-20211014084017760.png)



# First集

## 定义

![image-20211009111412576](ch4语法分析-自上而下.assets/image-20211009111412576.png)

*是在箭头上的，注意α是终结符！

因此我们只要保证每一个非终结符的FIRST集相交为空即可。，就不会出现回溯

对于*和+的解释：

![image-20211108114848298](ch4语法分析-自上而下.assets/image-20211108114848298.png)

## 文法符号的First集

![image-20211009111817663](ch4语法分析-自上而下.assets/image-20211009111817663.png)

注意最后两小点的理解：Yi推导不出来空字，前面都可以推导出空字，所以他们的F集合减去空字也是X的首符集元素
因为Y1可以推导出空字，因此X可以推导出Y2打头（Y2以及Y2的First集）
如果最后的Yn也可以推导出空字，那么X就可以推导出空字。

例题：没看懂

![image-20211014083844448](ch4语法分析-自上而下.assets/image-20211014083844448.png)

## 符号串的First集

![image-20211108115615471](ch4语法分析-自上而下.assets/image-20211108115615471.png)

就是说如果前j个X可以退出空字，那么第j+1个字符的首符集元素的F集就是符号串的First集合，同时空字也纳入符号串的First集合

例题：

![image-20211108134357885](ch4语法分析-自上而下.assets/image-20211108134357885.png)

# Follow集

## 定义

![image-20211014102106157](ch4语法分析-自上而下.assets/image-20211014102106157.png)

S是文法的起始符，终结符a是A的后继符
也就是能跟在A后面的终结符

![image-20211014102142791](ch4语法分析-自上而下.assets/image-20211014102142791.png)

即：如果A后面没有，则认为#跟在后面！就像空对于First

对于S，#都是后继符。

后继符不存在空字——任意一个符号都存在空字。

## 构造方法

![image-20211014102612441](ch4语法分析-自上而下.assets/image-20211014102612441.png)

第二个：只看右边

第三个：类似first中的转化

例如S->...B...就有S->...aA..

![image-20211014103445788](ch4语法分析-自上而下.assets/image-20211014103445788.png)

各集合对对应的对象以及含义

| 集        | 对象                       | 含义                                                         |
| --------- | -------------------------- | ------------------------------------------------------------ |
| FIRST 集  | 是对产生式右部             | 右部内部的所有终结符集，可能为 ε                             |
| FOLLOW 集 | 是对产生式左部（非终结符） | 非终结符后面紧跟的终结符，可能为 #，和该非终结符推导出的右部无关（因为LL(1)文法不包含递归，所以右部不会再有该非终结符，所以不能通过该右部判断该非终结符后跟集合） |

# LL（1）分析法

## 定义

从左(Left)到右扫描输入串；构造最左(Leftmost) 推导；分析时每步向前看一个(1)字符。

LL1 的意思：一次从左边只移动一个

## 分析条件

![image-20211014104335953](ch4语法分析-自上而下.assets/image-20211014104335953.png)

1和2很好理解

3： 假设交集为a，如果要推导a打头的式子，则
choice 1： a以First出现，直接选候选式
choice 2：以follow出现（以空字匹配）——这样又会有回溯



## 分析过程

符合LL（1）文法的语句就可以用LL（1）分析法进行分析

![image-20211014104319936](ch4语法分析-自上而下.assets/image-20211014104319936.png)



# 递归下降分析程序

就是LL（1）分析法的程序

从文法开始符号出发，在语法规则(文法产生式)的支配下进行语法分析。逐个扫描源程序中的字符(单词符号),根据文法和当前输入字符分析到下一个语法成分A时，便调用识别和分析A的子程序(或其自身)，如此继续下去。

程序通用的构造语法：

n个候选式有n+2个分支（一个error一个空字）

![image-20211014110128666](ch4语法分析-自上而下.assets/image-20211014110128666.png)

P（A）只有这几种情况，和上面的分析过程相对应

![image-20211014110139462](ch4语法分析-自上而下.assets/image-20211014110139462.png)

P指的是procedure

最后的终结符就可以read（ch）就行了，没必要像片偏移、t里面包装为P。



![image-20211108145522034](ch4语法分析-自上而下.assets/image-20211108145522034.png)

![image-20211108150306627](ch4语法分析-自上而下.assets/image-20211108150306627.png)

注意E'和T'的推导公式，他们可以推导出空字，所以有绿色部分。

# 预测分析程序

预测分析程序使用一个分析表符号栈进行联合控制。

最重要的是分析表，如果有递归、回溯，就需要预测分析程序。

## 基本思想

根据输入串的当前输入符确定选用某一个产生式进行推导，当该输入符与推导的第一个符号相同时，再取输入串的下一个符号，继续确定下一个推导应选的产生式，如此下去，直到推出被分析 的输入串为止。

由LL(1)分析表（预测分析表）、符号栈（后进先出） 、控制程序（表驱动程序）组成。

## LL（1）分析表

行标题为文法非终结符
列标题为文法终结符

比如这里E行i列就是指：E如果要退出i打头的串，应该用什么推导公式

构造算法：

对于G中的每一个产生式， A -> α ,执行以下2步：

1. for  ∀ a ∈ FIRST(α)， 将 A -> α 填入 M [A, a ];

2. if（ε ∈ FIRST(α)）

   ​	∀ a ∈ FOLLOW (A) ， 将 A -> ε 填入 M [A, a ];

PS: 其他的为空，这里的 a 包括 # 

## 总控程序

![image-20211108161843401](ch4语法分析-自上而下.assets/image-20211108161843401.png)

## 例子

![image-20211108161957175](ch4语法分析-自上而下.assets/image-20211108161957175.png)

假设要推出：i+i*i#
首先#和起始符E进栈，在输入中读到i，此时符号栈顶为E，因此找分析表中[E,i]发现是E->TE'
则E出栈，E'，T进栈
接下来T出栈，此时指向输入字符串的指针还停留在第一个i（没有直接推导到这个指针是不会动的），因此找[T,i]项，发现是T->FT'，因此T'，F进栈
接下来F出栈，仍然与i匹配，发现有F->i，因此F出栈，字符串指针指向下一个。

![image-20211108162503705](ch4语法分析-自上而下.assets/image-20211108162503705.png)
